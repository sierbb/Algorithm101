package BFS;

import java.util.*;

public class WordLadderII {

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> res = new ArrayList<>();
        //corner case:
        if (wordList == null || wordList.size() == 0 || wordList.indexOf(endWord)== -1 ){
            return res;
        }
        if (wordList.indexOf(beginWord) == -1){
            wordList.add(beginWord);
        }
        //Step 1: Build map for faster access to a word's index
        Map<String, Integer> map = new HashMap<>();
        for (int i=0; i<wordList.size(); i++){
            map.put(wordList.get(i), i);
        }
        Adjacency adjcencyList = new Adjacency(wordList);

        //Step 2: run BFS from beginWord to complete adjacnecylist along the way until we find endWord
        Queue<Integer> fifo = new LinkedList<Integer>();
        //need deduplicate in a path
        int[] visited = new int[wordList.size()]; //-> visited[i] represent the number of steps from beginWord for wordList[i]
        Arrays.fill(visited, -1);
        visited[map.get(beginWord)] = 0;
        fifo.offer(map.get(beginWord));

        while (!fifo.isEmpty()){
            //stop if fifo empty or find the endword
            int size = fifo.size();
            for (int i=0; i<size; i++){
                Integer curIdx = fifo.poll();
                int curlen = visited[curIdx];

                if (wordList.get(curIdx).equals(endWord)){
                    //get all possible path traceback from end to begin
                    return adjcencyList.getLadders(curIdx, map.get(beginWord));
                }

                //look at its neighbors
                for (Integer neiIdx : getNeighbors(curIdx, map, wordList)){
                    if (visited[neiIdx] == -1){
                        visited[neiIdx] = curlen+1;
                        fifo.offer(neiIdx);
                        adjcencyList.adjList.get(curIdx).add(neiIdx); //curIdx -> neiIdx
                        adjcencyList.predList.get(neiIdx).add(curIdx);
                    }else {
                        //filld in predecessor List if nei has been visited and is possible to be generated by cur
                        if (visited[neiIdx] == curlen+1){
                            adjcencyList.predList.get(neiIdx).add(curIdx); //curIdx -> neiIdx
                        }
                    }
                }
            }
            //got to next level
        }
        return res;
    }

    private List<Integer> getNeighbors(Integer index, Map<String, Integer> map, List<String> wordList){
        List<Integer> neighbors = new ArrayList<>();
        String word = wordList.get(index);
        StringBuilder sb = new StringBuilder(word);
        for (int i = 0; i<word.length(); i++){
            for (char j='a'; j<='z'; j++){
                if (j != word.charAt(i)){
                    sb.setCharAt(i, j);
                    if (map.containsKey(sb.toString())){
                        neighbors.add(map.get(sb.toString()));
                    }
                }
            }
            sb.setCharAt(i, word.charAt(i));
        }
        return neighbors;
    }

    public class Adjacency{
        private List<List<Integer>> adjList;
        private List<String> wordList;
        private List<List<Integer>> predList;

        public Adjacency(List<String> wordList){
            this.wordList = wordList;
            this.adjList = new ArrayList<List<Integer>>();
            this.predList = new ArrayList<List<Integer>>();
            for (int i=0; i<wordList.size(); i++){
                adjList.add(new ArrayList<Integer>());
                predList.add(new ArrayList<Integer>());
            }
        }

        public List<List<String>> getLadders(int beginIdx, int endIdx){ //for word index in wordList
            List<List<String>> out = new ArrayList<>();
            List<String> sol = new ArrayList<>();
            sol.add(wordList.get(beginIdx));
            DFS(beginIdx, endIdx, sol, out);
            return out;
        }

        private void DFS(int beginIdx, int endIdx, List<String> sol, List<List<String>> out){
            //base case when start and end overlap
            if (beginIdx == endIdx){
                List<String> subSol = new ArrayList<String>(sol);
                Collections.reverse(subSol);
                out.add(subSol);
                return;
            }
            for (Integer predIdx : predList.get(beginIdx)){
                sol.add(wordList.get(predIdx));
                DFS(predIdx, endIdx, sol, out);
                sol.remove(sol.size()-1);
            }
        }
    }


    public static void main(String[] args){
        List<String> input = new ArrayList<>();
        input.add("hot");
        input.add("dot");
        input.add("dog");
        input.add("lot");
        input.add("log");
        input.add("cog");
        WordLadderII obj = new WordLadderII();
        System.out.println(obj.findLadders("hit", "cog", input));

    }

}
